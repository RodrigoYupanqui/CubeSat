/*
 *  Project:    CubeSat Implementation (1U) for "Competencia Nacional de Pequeños Satélites 2024"
 *  Author:     Massimo Bruschi / Rodrigo Yupanqui / Josh Yauri (PUCP)
 *  Created:    26/12/2024
 *  Revised:    03/03/2025
 *  Description: Monitoring system for parameters such as acceleration, relative 
 *               humidity, geolocation, acceleration, among others. Sending of 
 *               data from a LoRa communication. 
 *  
 *  Development Board: ESP32 Dev Module (ESP-WROOM-32 Chip) 30 pins
 *  Hardware Configuration:
 *  - I2C BUS pins - Pin 21 (SDA) and Pin 22 (SCL) (These are for BME280, 
 *    MPU6050, INA219 and QMC5883L modules)
 *  - SPI pins - Pin 18 (SCK), Pin 19 (MISO) and Pin 23 (MOSI) (These are for the LoRa Module Ra-02)
 *  - Serial pins - Pin 16 (RX) and Pin 17 (Tx) (These are for NEO-6M module)
 *  - Everything operates on +3.3V (Could be external source or USB cable connection)
 *  
 */

#include <Wire.h>
#include <SPI.h>
#include <Adafruit_Sensor.h>     
#include <QMC5883LCompass.h>
#include <Adafruit_BME280.h>        
#include <Adafruit_MPU6050.h>
#include <Adafruit_INA219.h>
#include <TinyGPS++.h>
#include <HardwareSerial.h>
#include <LoRa.h>                  
#include <ESP32Servo.h>

// --- Pin Definitions ---

// Definition of pins for the I2C bus, used by multiple sensors:
//   - BME280 (pressure, temperature, and humidity)
//   - MPU6050 (accelerometer and gyroscope)
//   - INA219 (current sensor)
//   - QMC5883L (magnetometer)
#define SDA 21  // Pin for the I2C data line
#define SCL 22  // Pin for the I2C clock line

// Definition of pins for the GPS module
#define GPS_RX 16   // Pin to receive data from the GPS module (RX: Receive)
// Note: This pin should be connected to the TX pin of the GPS module.
#define GPS_TX 17   // Pin to send data to the GPS module (TX: Transmit)
// Note: This pin should be connected to the RX pin of the GPS module.

// Definition of pins for the LoRa module
#define LORA_SS 5   // Slave Select pin for the LoRa module
#define LORA_RST 14 // Reset pin for the LoRa module
#define LORA_DIO0 2 // Digital Input/Output pin 0 for the LoRa module (used to indicate events)
#define LORA_SCK 18 // Clock pin for the LoRa module's SPI bus
#define LORA_MISO 19 // Master In Slave Out pin for the LoRa module's SPI bus
#define LORA_MOSI 23 // Master Out Slave In pin for the LoRa module's SPI bus

// Initialize instances of various sensor and component classes
Adafruit_BME280 bme;      // Instance of the BME280 sensor for pressure, temperature, and humidity
Adafruit_MPU6050 mpu;     // Instance of the MPU6050 sensor for accelerometer and gyroscope data
Adafruit_INA219 ina219;   // Instance of the INA219 current sensor
TinyGPSPlus gps;          // Instance of the TinyGPSPlus library for GPS data processing
HardwareSerial serialGPS(2); // Serial interface for GPS communication (using UART2)
QMC5883LCompass compass;  // Instance of the QMC5883L magnetometer for compass readings
Servo servo1;              // First servo motor instance
Servo servo2;              // Second servo motor instance

float temperature, humidity, pressure;
float ax, ay, az, gx, gy, gz;
float mx, my, mz, azimuth;
char direction[3];
float voltage, current;
float latitude, longitude, altitude, speed, HDOP;  // Variables para almacenar los datos del GPS
float starting_height, height;
bool sentinel1 = false;
bool sentinel2 = true;

// Security configuration (by Josh Yauri)
const char* networkID = "MiRedLoRa";
const char* deviceID = "Dispositivo1";
const char* claveAutenticacion = "MiClaveSegura";

void setup() {
  // Configuración de los pines PWM para los servos
  // Los pines recomendados para PWM en ESP32 son 2, 4, 12-19, 21-23, 25-27, 32-33
  servo1.attach(4); // Pin 4 para el primer servo
  servo2.attach(13); // Pin 13 para el segundo servo

  // Configuración inicial de los servos a 0 grados
  servo1.write(0);
  servo2.write(0);
  
  Serial.begin(115200);
  Wire.begin();
   
  // GPS
  serialGPS.begin(9600, SERIAL_8N1, 16, 17);  
  delay(1000);

  // Magnetometro
  compass.init();
  compass.setCalibrationOffsets(-276.00, 269.00, -348.00);
  compass.setCalibrationScales(1.08, 1.11, 0.86);

  // Sensor de temperature, humidity y presión
  if (!bme.begin(0x76)) {
    Serial.println("BME280 not found.");
    while(!bme.begin(0x76)){
      delay(1000);
    }
    Serial.println("BME280 found.");
  }

  // Accelerometer / Gyroscope
  if (!mpu.begin()) {
    Serial.println("Failed to find MPU6050 chip");
    while(!mpu.begin()) {
      delay(1000);
    }
    Serial.println("MPU6050 Found!");
  }
  
  // Current Sensor
  if (!ina219.begin()) {
    Serial.println("INA219 not found.");
    while(!ina219.begin()) {
      delay(1000);
    }
    Serial.println("INA219 Found!");
  }
  
  // LoRa Module
  SPI.begin(LORA_SCK, LORA_MISO, LORA_MOSI, LORA_SS);
  LoRa.setPins(LORA_SS, LORA_RST, LORA_DIO0);
  if (!LoRa.begin(433E6)) {  // LoRa frequency (example: 433MHz)
    Serial.println("Error starting LoRa.");
    while(!LoRa.begin(433E6)) {
      delay(1000);
    }
    Serial.println("LoRa initialized.");
  }
  LoRa.setSyncWord(0xF3);
  Serial.println("Complete initialization.");
}

void loop() {
  readBME280();
  readMPU6050();
  readQMC5883L();
  readINA219();
  readGPS();

  String message = buildMessage();
  sendLoRa(message);

  if(height>85){
    sentinel1 = true;
  }
  if(sentinel1){
    if(80>height){
      servomotores();   
    }
  }
  delay(500);
}

void servomotores() {
  servo1.write(90);
  servo2.write(90);
}

void readBME280() {
  temperature = bme.readTemperature();
  humidity = bme.readHumidity();
  pressure = bme.readPressure() / 100.0F;
  altitude = (1 - pow((pressure / 1013.25), (1 / 5.2559))) / 0.0000225577;
  if(sentinel2){
    sentinel2 = false;
    starting_height = altitude;
  }
  height = altitude - starting_height;
}

void readMPU6050() {
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);
  ax = a.acceleration.x;
  ay = a.acceleration.y;
  az = a.acceleration.z;
  gx = g.gyro.x;
  gy = g.gyro.y;
  gz = g.gyro.z;
}

void readQMC5883L() {
  compass.read();
  mx = compass.getX();
  my = compass.getY();
  mz = compass.getZ();
  azimuth = compass.getAzimuth();
  compass.getDirection(direction, azimuth);
}

void readINA219() {
  voltage = ina219.getBusVoltage_V();
  current = ina219.getCurrent_mA();
}

void readGPS() {
  while (serialGPS.available() > 0) {
    if (gps.encode(serialGPS.read())) {
      if (gps.location.isValid()) {
        latitude = gps.location.lat();
        longitude = gps.location.lng();
        speed = gps.speed.kmph();
        HDOP = gps.hdop.value() / 100.0;
        break;
      } else {
        Serial.println("GPS doesn't read coherent things");
      }
    }
  }
}

// --- Message Construction ---
String buildMessage() {
  // Create a JSON object with double quotes
  String message = "{";
  message += "\"Voltage\": " + String(voltage) + ",";
  message += "\"Current\": " + String(current) + ",";
  message += "\"Temperature\": " + String(temperature) + ",";
  message += "\"Humidity\": " + String(humidity) + ",";
  message += "\"Pressure\": " + String(pressure) + ",";
  message += "\"AccelerationX\": " + String(ax, 3) + ",";
  message += "\"AccelerationY\": " + String(ay, 3) + ",";
  message += "\"AccelerationZ\": " + String(az, 3) + ",";
  message += "\"RotationX\": " + String(gx, 3) + ",";
  message += "\"RotationY\": " + String(gy, 3) + ",";
  message += "\"RotationZ\": " + String(gz, 3) + ",";
  message += "\"MagneticFieldX\": " + String(mx) + ",";
  message += "\"MagneticFieldY\": " + String(my) + ",";
  message += "\"MagneticFieldZ\": " + String(mz) + ",";
  message += "\"Azimuth\": " + String(azimuth) + ",";
  message += "\"Direction\": \"" + String(direction) + "\",";
  message += "\"latitude\": " + String(latitude, 3) + ",";
  message += "\"longitude\": " + String(longitude, 3) + ",";
  message += "\"altitude\": " + String(altura) + ",";
  message += "\"Speed\": " + String(speed) + ",";
  message += "\"HDOP\": " + String(HDOP);
  message += "}";
  return message;
}

// --- Sending Data by LoRa by Josh Yauri ---
void sendLoRa(String message) {
  int longitude = message.length();
  int sizemax = 50; // Maximum characters per package
  int start = 0;
  
  while (start < longitude) {
    String PartOfMessage = message.substring(start, min(start + sizemax, longitude));
    LoRa.beginPacket();
    LoRa.print(PartOfMessage);
    LoRa.endPacket();
    Serial.println("Message sent by LoRa: " + PartOfMessage);
    delay(50); // Short break between shipments
    start += sizemax;
  }
  Serial.println("Message sent message sent in full");
}
